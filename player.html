<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="referrer" content="strict-origin-when-cross-origin" />
    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
      #youTubePlayer {
        width: 100%;
        height: 100%;
      }
    </style>
    <script src="https://www.youtube.com/iframe_api" async></script>
  </head>
  <body>
    <div id="youTubePlayer"></div>

    <script>
      const q = new URLSearchParams(location.search);
      const videoId = q.get("videoId") || "";
      const startAt = parseFloat(q.get("start") || "0");

      const STATES = {
        [-1]: "UNSTARTED",
        0: "ENDED",
        1: "PLAYING",
        2: "PAUSED",
        3: "BUFFERING",
        5: "CUED",
      };

      let player, timer;
      // let lastVolume = -1;
      // let lastMuted = null;
      // let volumeDebounceTimer = null;

      function onYouTubeIframeAPIReady() {
        player = new YT.Player("youTubePlayer", {
          width: "100%",
          height: "100%",
          playerVars: {
            autoplay: 1,
            controls: 0,
            cc_load_policy: 0,
            fs: 1,
            iv_load_policy: 3,
            rel: 0,
            enablejsapi: 1,
            mute: 1,
            playsinline: 1,
            origin: location.origin,
            modestbranding: 1,
            disablekb: 1,
            showinfo: 0,
          },
          events: {
            onReady: () => {
              document.title = "ytplayer://onReady";
              if (videoId) loadVideo(videoId, startAt);
            },
            onStateChange: (e) => stateChanged(e.data),
            onError: (e) =>
              (document.title = "ytplayer://onError?data=" + e.data),
          },
        });
      }

      function stateChanged(s) {
        clearInterval(timer);
        document.title = "ytplayer://onStateChange?data=" + (STATES[s] || "");
        if (s === 1) {
          timer = setInterval(() => {
            try {
              document.title =
                "ytplayer://onCurrentTimeChange?data=" +
                player.getCurrentTime();
            } catch (e) {}
          }, 200);
          try {
            const d = player.getDuration();
            if (d > 0)
              document.title = "ytplayer://onVideoDuration?data=" + d;
          } catch (e) {}
        }
      }

      function loadVideo(id, sec) {
        if (player && player.loadVideoById) {
          player.loadVideoById(id, sec || 0);
          document.title = "ytplayer://onVideoId?data=" + id;
        }
      }

      function playVideo() {
        if (player && player.playVideo) player.playVideo();
      }

      function pauseVideo() {
        if (player && player.pauseVideo) player.pauseVideo();
      }

      function seekTo(s) {
        if (player && player.seekTo) player.seekTo(s, true);
      }

      function mute() {
        if (player && player.mute) player.mute();
      }

      function unMute() {
        if (player && player.unMute) player.unMute();
      }

          
      function setVolume(volumePercent) {
      //   try {
      //     if (!player || typeof player.setVolume !== "function") return;
      
      //     let v = Number(volumePercent);
      //     if (isNaN(v)) return;
      
      //     // Clamp 0–100
      //     v = Math.max(0, Math.min(100, Math.round(v)));
      
      //     // If same value as last applied, ignore
      //     if (v === lastVolume) return;
      
      //     // Clear any pending debounce
      //     if (volumeDebounceTimer) {
      //       clearTimeout(volumeDebounceTimer);
      //       volumeDebounceTimer = null;
      //     }
      
      //     // Debounce application — only apply after user stops dragging (~100ms)
      //     volumeDebounceTimer = setTimeout(() => {
      //       try {
      //         lastVolume = v;
      //         player.setVolume(v);
      
      //         const shouldBeMuted = v === 0;
      //         if (shouldBeMuted !== lastMuted) {
      //           lastMuted = shouldBeMuted;
      //           if (shouldBeMuted && typeof player.mute === "function") player.mute();
      //           else if (!shouldBeMuted && typeof player.unMute === "function") player.unMute();
      //         }
      
      //       } catch (e) {
      //         console.warn("Debounced setVolume error", e);
      //       }
      //     }, 100); // 100 ms delay — adjust if needed
      
      //   } catch (e) {
      //     console.warn("setVolume error", e);
      //   }
      }

      function setPlaybackRate(r) {
        if (player && player.setPlaybackRate) player.setPlaybackRate(r);
      }
      
    </script>
  </body>
</html>
